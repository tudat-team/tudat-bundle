import argparse
import ast
from pathlib import Path
import os
import sys
import subprocess
import tempfile

# Version with stubs

TUDATPY_ROOT = Path("tudatpy/src/tudatpy").resolve()
CONDA_PREFIX = os.environ["CONDA_PREFIX"]
PYLIB_PREFIX = (
    Path(sys.exec_prefix)
    / sys.platlibdir
    / f"python{sys.version_info.major}.{sys.version_info.minor}"
    / "site-packages"
).resolve()


class _StubGenerator:
    """Stub generation"""

    def __init__(self, clean: bool, root_suffix: str, build_dir: Path) -> None:

        self.clean = clean
        self.root_suffix = root_suffix
        self.stubs_root = (
            TUDATPY_ROOT.parent / f"{TUDATPY_ROOT.name}{root_suffix}"
        )

        return None

    def generate_stubs(self, source_dir: Path) -> None:
        """Generates stubs for a package.

        :param source_dir: Path to base directory of the package
        """

        # Generate stub for main init file
        print("Generating stub for __init__.py...")
        # self._generate_init_stub(source_dir)
        self.generate_init_stub(source_dir)

        # Generate stubs for C++ extensions
        # NOTE: Done here so that they are available when generating the stubs
        # for the submodules
        for extension in source_dir.rglob("*.so"):

            # Define path to stub file
            _stub = extension.relative_to(TUDATPY_ROOT).parent / extension.stem
            _stub = self.stubs_root / _stub.with_suffix(".pyi")

            # Skip extension if stub exists and clean flag is not set
            if _stub.exists() and not self.clean:
                print(f"Skipping {_stub.name}...")
                continue

            # Generate stub
            self.__generate_stub(extension)

        # # Generate stubs for Python scripts
        # for script in source_dir.rglob("*.py"):

        #     # Skip script if it is the main __init__ file
        #     if script.name == "__init__.py":
        #         continue

        #     # Define path to stub file
        #     _stub = script.relative_to(TUDATPY_ROOT).parent / script.stem
        #     _stub = self.stubs_root / _stub.with_suffix(".pyi")

        #     # Skip script if stub exists and clean flag is not set
        #     if _stub.exists() and not self.clean:
        #         print(f"Skipping {_stub.name}...")
        #         continue

        #     # Generate stub
        #     self.__generate_stub(script)

        # exit(0)

        # Loop over submodules
        for submodule in source_dir.iterdir():

            # Only process actual submodules
            if not submodule.is_dir():
                continue
            if submodule.name in SKIP_MODULES:
                print(f"IGNORED: {submodule.name}")
                continue
            if not (submodule / "__init__.py").exists():
                continue

            # Generate stubs for submodules
            self._generate_module_stubs(submodule)

        return None

    def __generate_stub(self, script: Path) -> None:
        """Generate stub file"""

        # Define import path
        import_path = str(
            script.relative_to(TUDATPY_ROOT).parent / script.stem
        ).replace("/", ".")
        import_path = f"tudatpy.{import_path}"

        # Generate stubs
        outcome = subprocess.run(
            [
                "pybind11-stubgen",
                import_path,
                "-o",
                ".",
                f"--root-suffix={self.root_suffix}",
                "--numpy-array-remove-parameters",
            ]
        )
        if outcome.returncode:
            raise RuntimeError(f"Failed to generate stub for {import_path}")

        # Clean autogenerated stub
        self._clean_autogenerated_stub(import_path)

        return None

    def _generate_module_stubs(self, module_path: Path) -> None:
        """Generates stubs for a module

        :param module_path: Path to module directory
        """

        # Loop over submodules
        for submodule in module_path.iterdir():
            if submodule.is_dir() and (submodule / "__init__.py").exists():
                self._generate_module_stubs(submodule)

        # Define import path and display info
        import_path = f'tudatpy.{str(module_path.relative_to(TUDATPY_ROOT)).replace("/", ".")}'

        # Generate __init__ stub
        # self._generate_init_stub(module_path)
        self.generate_init_stub(module_path)

        # Find python scripts included in __init__
        _content = ast.parse((module_path / "__init__.py").read_text())

        _python_modules = []
        for _statement in _content.body:
            if isinstance(_statement, ast.ImportFrom):
                if (
                    "expose" in str(_statement.module)
                    or _statement.module is None
                ):
                    continue
                _python_modules.append(_statement.module)

        # Generate stubs for python scripts
        for _python_module in _python_modules:

            # Skip extension if stub exists and clean flag is not set
            script_import_path = f"{import_path}.{_python_module}"
            script_stub_path = self.stubs_root / Path(
                "/".join(script_import_path.split(".")[1:])
            ).with_suffix(".pyi")
            if script_stub_path.exists() and not self.clean:
                continue
            print(f"Generating stub for {script_import_path}...")
            outcome = subprocess.run(
                [
                    "pybind11-stubgen",
                    script_import_path,
                    "-o",
                    ".",
                    f"--root-suffix={self.root_suffix}",
                    "--numpy-array-remove-parameters",
                ]
            )
            if outcome.returncode:
                exit(outcome.returncode)

            # Clean autogenerated stub
            self._clean_autogenerated_stub(script_import_path)

        return None

    @staticmethod
    def _adjust_docstring_indentation(text):

        # Replace tabs with character not affected by strip
        text = text.replace("    ", "¿")

        # Split input into lines and remove leading/trailing whitespace
        lines = [line.strip() for line in text.splitlines()]
        while lines[0] == "":
            lines.pop(0)

        # Find indentation level of first line
        lev0 = len(lines[0].split("¿"))
        lev1 = lev0
        for line in lines[1:]:
            if line != "":
                lev1 = len(line.split("¿"))
                break
        diff = lev1 - lev0

        # Adjust indentation for all lines
        newlines = [lines[0].replace("¿", "")]
        for line in lines[1:]:
            terms = line.split("¿")[diff:]
            line = "\t".join(terms)
            newlines.append(("\t" * lev0) + line)

        return "\n".join(newlines) + "\n" + ("\t" * lev0)

    def _generate_init_stub(self, module_path: Path) -> None:
        """Generates stub for __init__ file

        :param module_path: Path to module directory
        """

        # Define path to stub file
        stub_path = module_path.relative_to(TUDATPY_ROOT)
        stub_path = self.stubs_root / f"{stub_path}/__init__.pyi"

        # Parse __init__ file
        with open(module_path / "__init__.py") as src:
            content = ast.parse(src.read())

        import_statements = []
        other_statements = []
        for statement in content.body:

            if isinstance(statement, ast.Import):
                import_statements.append(statement)
            elif isinstance(statement, ast.ImportFrom):
                if statement.names[0].name == "*":
                    assert statement.module is not None
                    __file = (
                        stub_path.parent
                        / f"{statement.module.replace('.', '/')}.pyi"
                    )
                    if not __file.exists():
                        __file = __file.with_suffix(".py")
                        print("USING PYTHON FILE!!!!")

                    if not __file.exists():
                        raise FileNotFoundError("Failed")

                    with __file.open() as f:
                        _data = ast.parse(f.read())
                        for _statement in _data.body:
                            if (
                                isinstance(_statement, ast.Assign)
                                and len(_statement.targets) == 1
                                and isinstance(_statement.targets[0], ast.Name)
                                and _statement.targets[0].id == "__all__"
                            ):
                                assert isinstance(_statement.value, ast.List)
                                _equivalent_import = ast.ImportFrom(
                                    module=statement.module,
                                    level=statement.level,
                                    names=[
                                        ast.alias(name=elt.value)  # type: ignore
                                        for elt in _statement.value.elts
                                    ],
                                )
                                import_statements.append(_equivalent_import)
                else:
                    import_statements.append(statement)

            elif isinstance(statement, ast.Assign):
                if statement.targets[0].id == "__all__":  # type: ignore
                    continue
                other_statements.append(statement)

            else:
                raise NotImplementedError(
                    f"Failed to parse {module_path / '__init__.py'}: "
                    f"Statement type {type(statement)} not supported."
                )

        # Generate import statement for submodules
        submodule_list = []
        for submodule in module_path.iterdir():
            if submodule.is_dir() and (submodule / "__init__.py").exists():
                submodule_list.append(submodule)

        if len(submodule_list) > 0:
            import_submodules_statement = ast.ImportFrom(
                module="",
                level=1,
                names=[
                    ast.alias(name=submodule.name)
                    for submodule in submodule_list
                ],
            )
            import_statements.append(import_submodules_statement)

        # Generate __all__ statement
        if len(import_statements) == 0:
            all_statement = ast.parse("__all__ = []").body[0]
        else:
            all_statement = ast.parse(
                "__all__ = ["
                + ", ".join(
                    [
                        f"'{alias.name}'"
                        for statement in import_statements
                        for alias in statement.names
                    ]
                )
                + "]"
            ).body[0]

        # Generate __init__.pyi
        init_contents = import_statements + other_statements + [all_statement]
        init_module = ast.Module(body=init_contents, type_ignores=[])
        stub_path.parent.mkdir(parents=True, exist_ok=True)
        with open(stub_path, "w") as f:
            f.write(ast.unparse(init_module))

        return None

    def _clean_autogenerated_stub(self, import_path: str) -> None:
        """Cleans autogenerated stub

        :param import_path: Import path to module
        """

        stub_path = self.stubs_root / Path(
            "/".join(import_path.split(".")[1:])
        ).with_suffix(".pyi")

        with open(stub_path) as f:
            content = ast.parse(f.read())

        includes_typing = False
        for idx, statement in enumerate(content.body):

            if isinstance(statement, ast.ImportFrom):
                if statement.module == "__future__":
                    content.body.remove(statement)

            if isinstance(statement, ast.Import):
                for alias in statement.names:
                    if alias.name == "typing":
                        includes_typing = True
                        break

            if isinstance(
                statement,
                (
                    ast.ClassDef,
                    ast.FunctionDef,
                    ast.AsyncFunctionDef,
                    ast.Module,
                ),
            ):
                _docstring = ast.get_docstring(statement, clean=True)
                if _docstring is not None:
                    _docstring = StubGenerator._adjust_docstring_indentation(
                        _docstring
                    )
                    statement.body.pop(0)
                    statement.body.insert(0, ast.Expr(ast.Constant(_docstring)))

        if not includes_typing:
            content.body.insert(0, ast.Import([ast.alias("typing")]))

        with open(stub_path, "w") as f:
            f.write(ast.unparse(content))

        return None

    def generate_init_stub(self, module_path: Path) -> None:
        """Generates stub for __init__ file of a module

        In tudat, the standard __init__ file of a module contains a star import from its extension module, and concrete import statements from the python scripts in it. Aside from adding the imports from Python scripts, this function expands the star import into a list of functions, classes... and also creates a list to explicitly import all the submodules.

        :param module_path: Path to module directory
        """

        # Define paths to source and stub files
        source_path = module_path / "__init__.py"
        stub_path = module_path.relative_to(TUDATPY_ROOT)
        stub_path = self.stubs_root / f"{stub_path}/__init__.pyi"

        # Initialize data containers
        import_statements: list[ast.Import | ast.ImportFrom] = []
        other_statements: list[ast.stmt] = []
        submodule_list: list[Path] = []

        # Parse content of source file (__init__.py)
        with source_path.open("r") as src:
            source_content = ast.parse(src.read())

        # Classify statements in source file
        for statement in source_content.body:

            # Basic import statement: import X
            if isinstance(statement, ast.Import):

                import_statements.append(statement)

            # Import from statement: from X import Y // import Y from X
            elif isinstance(statement, ast.ImportFrom):

                # If not star import, append and continue
                if statement.names[0].name != "*":
                    import_statements.append(statement)
                    continue

                # Define path to stub file for extension module
                assert statement.module is not None  # Sanity
                _source = (
                    stub_path.parent
                    / f"{statement.module.replace('.', '/')}.pyi"
                )

                # If stub does not exist, look for Python script
                if not _source.exists():
                    _source = _source.with_suffix(".py")

                # If Python script does not exist, source is missing
                if not _source.exists():
                    raise FileNotFoundError(
                        f"Failed to generate stubs for {module_path.name}: "
                        "Could not expand star import in __init__.py"
                    )
                else:
                    # Generate stub from python script
                    self.__generate_stub(_source)

                    # Use new stub as source
                    _source = _source.with_suffix(".pyi")
                    assert _source.is_file()  # Sanity

                # Parse content of source file
                _data = ast.parse(_source.read_text())

                # Source is a stub, so it has an __all__ statement
                _all_found: bool = False
                for _statement in _data.body:

                    # Filter out statements that are not __all__ = [...]
                    if not isinstance(_statement, ast.Assign):
                        continue
                    if len(_statement.targets) != 1:
                        continue
                    if not isinstance(_statement.targets[0], ast.Name):
                        continue
                    if _statement.targets[0].id != "__all__":
                        continue

                    # Generate "import from" from __all__ statement
                    _all_found = True
                    assert isinstance(_statement.value, ast.List)  # Sanity
                    imported_items = [
                        ast.alias(name=x.value)  # type: ignore
                        for x in _statement.value.elts
                    ]
                    import_statements.append(
                        ast.ImportFrom(
                            module=statement.module,
                            level=statement.level,
                            names=imported_items,
                        )
                    )

                # Should have found an __all__ statement
                if not _all_found:
                    raise RuntimeError(
                        "Failed to generate stubs for {module_path.name}: "
                        "Could not expand star import in __init__.py"
                    )

            # Assign statement different from __all__ = [...]
            elif isinstance(statement, ast.Assign):

                # Skip __all__ statement
                assert isinstance(statement.targets[0], ast.Name)  # Sanity
                if statement.targets[0].id == "__all__":
                    continue

                # Append to other statements
                other_statements.append(statement)

            else:
                continue
                # raise NotImplementedError(
                #     f"Failed to parse {module_path / '__init__.py'}: "
                #     f"Statement type {type(statement)} not supported."
                # )

        # Find submodules of current module
        for submodule in module_path.iterdir():

            # Filter out anything that is not a submodule
            if not submodule.is_dir():
                continue
            if not (submodule / "__init__.py").exists():
                continue

            # Append to submodule list
            submodule_list.append(submodule)

        # Generate import statement for submodules
        if len(submodule_list) > 0:

            _submodules = [
                ast.alias(name=submodule.name)  # type: ignore
                for submodule in submodule_list
            ]
            import_statements.append(
                ast.ImportFrom(module="", level=1, names=_submodules)
            )

        # Generate __all__ statement
        if len(import_statements) == 0:
            all_statement = ast.parse("__all__ = []").body[0]
        else:
            all_statement = ast.parse(
                "__all__ = ["
                + ", ".join(
                    [
                        f"'{alias.name}'"
                        for statement in import_statements
                        for alias in statement.names
                    ]
                )
                + "]"
            ).body[0]

        # Generate __init__.pyi
        init_contents = import_statements + other_statements + [all_statement]
        init_module = ast.Module(body=init_contents, type_ignores=[])
        stub_path.parent.mkdir(parents=True, exist_ok=True)
        stub_path.write_text(ast.unparse(init_module))

        return None


class StubParser(argparse.ArgumentParser):

    def __init__(self) -> None:

        super().__init__(prog="stubs.py")

        self.add_argument(
            "--root-suffix",
            dest="root_suffix",
            default="",
            help="To be appended to the name of the root directory of the stubs",
        )

        return None


class StubGenerator:

    def __init__(self) -> None:

        # Initialize attributes from user input
        self.args = StubParser().parse_args()
        self.root_suffix = self.args.root_suffix
        self.base = PYLIB_PREFIX / "tudatpy"

        return None

    def generate_kernel_stubs(self) -> None:

        with tempfile.TemporaryDirectory() as tmp:

            print(Path(tmp).resolve())

            # Generate default stubs
            outcome = subprocess.run(
                [
                    "pybind11-stubgen",
                    "tudatpy.kernel",
                    "-o",
                    tmp,
                    f"--root-suffix={self.root_suffix}",
                    "--numpy-array-remove-parameters",
                ]
            )
            if outcome.returncode:
                raise RuntimeError("Failed to generate stub for tudatpy.kernel")


if __name__ == "__main__":

    stubs = StubGenerator()
    stubs.generate_kernel_stubs()
