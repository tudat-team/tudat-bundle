import os
import sys
import subprocess
from pathlib import Path
from contextlib import chdir

import argparse
import shutil
import ast

##################################

# Globals
TUDATPY_ROOT = Path("tudatpy/src/tudatpy").absolute()
STUBS_ROOT = Path("tudatpy/src/tudatpy-stubs").absolute()
CONDA_PREFIX = os.environ["CONDA_PREFIX"]
PYLIB_PREFIX = (
    Path(sys.exec_prefix)
    / sys.platlibdir
    / f"python{sys.version_info.major}.{sys.version_info.minor}"
    / "site-packages"
).resolve()


class StubGenerator:
    """Stub generation"""

    def __init__(self, clean: bool = False) -> None:
        self.clean = clean
        return None

    def generate_stubs(self, source_dir: Path) -> None:
        """Generates stubs for a package.

        :param source_dir: Path to base directory of the package
        """

        # Generate stub for main init file
        StubGenerator._generate_init_stub(source_dir)

        # Generate stubs for C++ extensions
        for extension in source_dir.rglob("*.so"):

            # Skip extension if stub exists and clean flag is not set
            extension_stub_path = STUBS_ROOT / extension.relative_to(
                TUDATPY_ROOT
            ).with_suffix("").with_suffix(".pyi")
            if extension_stub_path.exists() and not self.clean:
                continue

            # Generate stub
            extension_import_path = f"tudatpy.{str(extension.relative_to(TUDATPY_ROOT).with_suffix('').with_suffix('')).replace('/', '.')}"
            print(f"Generating stubs for {extension_import_path}...")
            outcome = subprocess.run(
                [
                    "pybind11-stubgen",
                    extension_import_path,
                    "-o",
                    ".",
                    "--root-suffix=-stubs",
                    "--numpy-array-remove-parameters",
                ]
            )
            if outcome.returncode:
                exit(outcome.returncode)

            # Clean autogenerated stub
            self._clean_autogenerated_stub(extension_import_path)

        # Loop over submodules
        for submodule in source_dir.iterdir():
            if submodule.is_dir() and (submodule / "__init__.py").exists():
                self._generate_module_stubs(submodule)

        return None

    def _generate_module_stubs(self, module_path: Path) -> None:
        """Generates stubs for a module

        :param module_path: Path to module directory
        """

        # Loop over submodules
        for submodule in module_path.iterdir():
            if submodule.is_dir() and (submodule / "__init__.py").exists():
                self._generate_module_stubs(submodule)

        # Define import path and display info
        import_path = f'tudatpy.{str(module_path.relative_to(TUDATPY_ROOT)).replace("/", ".")}'

        # Generate __init__ stub
        StubGenerator._generate_init_stub(module_path)

        # Find python scripts included in __init__
        with open(module_path / "__init__.py") as _f:
            _content = ast.parse(_f.read())

        _python_modules = []
        for _statement in _content.body:
            if isinstance(_statement, ast.ImportFrom):
                if (
                    "expose" in str(_statement.module)
                    or _statement.module is None
                ):
                    continue
                _python_modules.append(_statement.module)

        # Generate stubs for python scripts
        for _python_module in _python_modules:

            # Skip extension if stub exists and clean flag is not set
            script_import_path = f"{import_path}.{_python_module}"
            script_stub_path = STUBS_ROOT / Path(
                "/".join(script_import_path.split(".")[1:])
            ).with_suffix(".pyi")
            if script_stub_path.exists() and not self.clean:
                continue
            print(f"Generating stub for {script_import_path}...")
            outcome = subprocess.run(
                [
                    "pybind11-stubgen",
                    script_import_path,
                    "-o",
                    ".",
                    "--root-suffix=-stubs",
                    "--numpy-array-remove-parameters",
                ]
            )
            if outcome.returncode:
                exit(outcome.returncode)

            # Clean autogenerated stub
            self._clean_autogenerated_stub(script_import_path)

        return None

    @staticmethod
    def _adjust_docstring_indentation(text):

        # Replace tabs with character not affected by strip
        text = text.replace("    ", "¿")

        # Split input into lines and remove leading/trailing whitespace
        lines = [line.strip() for line in text.splitlines()]
        while lines[0] == "":
            lines.pop(0)

        # Find indentation level of first line
        lev0 = len(lines[0].split("¿"))
        lev1 = lev0
        for line in lines[1:]:
            if line != "":
                lev1 = len(line.split("¿"))
                break
        diff = lev1 - lev0

        # Adjust indentation for all lines
        newlines = [lines[0].replace("¿", "")]
        for line in lines[1:]:
            terms = line.split("¿")[diff:]
            line = "\t".join(terms)
            newlines.append(("\t" * lev0) + line)

        return "\n".join(newlines) + "\n" + ("\t" * lev0)

    @staticmethod
    def _generate_init_stub(module_path: Path) -> None:
        """Generates stub for __init__ file

        :param module_path: Path to module directory
        """
        # Define path to stub file
        stub_path = module_path.relative_to(TUDATPY_ROOT)
        stub_path = STUBS_ROOT / f"{stub_path}/__init__.pyi"

        # Parse __init__ file
        with open(module_path / "__init__.py") as src:
            content = ast.parse(src.read())

        import_statements = []
        other_statements = []
        for statement in content.body:

            if isinstance(statement, ast.Import):
                raise NotImplementedError("Import statement not supported yet")
            elif isinstance(statement, ast.ImportFrom):
                if statement.names[0].name == "*":
                    assert statement.module is not None
                    with (
                        stub_path.parent
                        / f"{statement.module.replace('.', '/')}.pyi"
                    ).open() as f:
                        _data = ast.parse(f.read())
                        for _statement in _data.body:
                            if (
                                isinstance(_statement, ast.Assign)
                                and len(_statement.targets) == 1
                                and isinstance(_statement.targets[0], ast.Name)
                                and _statement.targets[0].id == "__all__"
                            ):
                                assert isinstance(_statement.value, ast.List)
                                _equivalent_import = ast.ImportFrom(
                                    module=statement.module,
                                    level=statement.level,
                                    names=[
                                        ast.alias(name=elt.value)  # type: ignore
                                        for elt in _statement.value.elts
                                    ],
                                )
                                import_statements.append(_equivalent_import)
                else:
                    import_statements.append(statement)

            elif isinstance(statement, ast.Assign):
                if statement.targets[0].id == "__all__":  # type: ignore
                    continue
                other_statements.append(statement)

        # Generate import statement for submodules
        submodule_list = []
        for submodule in module_path.iterdir():
            if submodule.is_dir() and (submodule / "__init__.py").exists():
                submodule_list.append(submodule)

        if len(submodule_list) > 0:
            import_submodules_statement = ast.ImportFrom(
                module="",
                level=1,
                names=[
                    ast.alias(name=submodule.name)
                    for submodule in submodule_list
                ],
            )
            import_statements.append(import_submodules_statement)

        # Generate __all__ statement
        if len(import_statements) == 0:
            all_statement = ast.parse("__all__ = []").body[0]
        else:
            all_statement = ast.parse(
                "__all__ = ["
                + ", ".join(
                    [
                        f"'{alias.name}'"
                        for statement in import_statements
                        for alias in statement.names
                    ]
                )
                + "]"
            ).body[0]

        # Generate __init__.pyi
        init_contents = import_statements + other_statements + [all_statement]
        init_module = ast.Module(body=init_contents, type_ignores=[])
        stub_path.parent.mkdir(parents=True, exist_ok=True)
        with open(stub_path, "w") as f:
            f.write(ast.unparse(init_module))

        return None

    @staticmethod
    def _clean_autogenerated_stub(import_path: str) -> None:
        """Cleans autogenerated stub

        :param import_path: Import path to module
        """

        stub_path = STUBS_ROOT / Path(
            "/".join(import_path.split(".")[1:])
        ).with_suffix(".pyi")

        with open(stub_path) as f:
            content = ast.parse(f.read())

        includes_typing = False
        for idx, statement in enumerate(content.body):

            if isinstance(statement, ast.ImportFrom):
                if statement.module == "__future__":
                    content.body.remove(statement)

            if isinstance(statement, ast.Import):
                for alias in statement.names:
                    if alias.name == "typing":
                        includes_typing = True
                        break

            if isinstance(
                statement,
                (
                    ast.ClassDef,
                    ast.FunctionDef,
                    ast.AsyncFunctionDef,
                    ast.Module,
                ),
            ):
                _docstring = ast.get_docstring(statement, clean=True)
                if _docstring is not None:
                    _docstring = StubGenerator._adjust_docstring_indentation(
                        _docstring
                    )
                    statement.body.pop(0)
                    statement.body.insert(0, ast.Expr(ast.Constant(_docstring)))

        if not includes_typing:
            content.body.insert(0, ast.Import([ast.alias("typing")]))

        with open(stub_path, "w") as f:
            f.write(ast.unparse(content))

        return None


def setup_build_dir(args: argparse.Namespace, build_dir: Path) -> None:
    """Set up CMake build directory"""

    # Delete build directory if clean build is requested
    if build_dir.exists() and args.clean:
        shutil.rmtree(build_dir)

    # Set up build directory
    if (not build_dir.exists()) or (args.setup):
        outcome = subprocess.run(
            [
                "cmake",
                f"-DSKIP_TUDAT={args.skip_tudat}",
                f"-DSKIP_TUDATPY={args.skip_tudatpy}",
                f"-DCMAKE_PREFIX_PATH={CONDA_PREFIX}",
                f"-DCMAKE_INSTALL_PREFIX={CONDA_PREFIX}",
                f"-DCMAKE_CXX_STANDARD={args.cxx_standard}",
                "-DBoost_NO_BOOST_CMAKE=ON",
                f"-DCMAKE_BUILD_TYPE={args.build_type}",
                f"-DTUDAT_BUILD_TESTS={args.tudat_tests}",
                f"-DTUDAT_BUILD_WITH_SOFA_INTERFACE={args.sofa}",
                f"-DTUDAT_BUILD_WITH_NRLMSISE00={args.nrlmsise00}",
                f"-DTUDAT_BUILD_WITH_PAGMO={args.pagmo}",
                f"-DTUDAT_BUILD_WITH_JSON_INTERFACE={args.json}",
                f"-DTUDAT_BUILD_WITH_EXTENDED_PRECISION_PROPAGATION_TOOLS={args.extended_precision}",
                "-B",
                f"{build_dir}",
                "-S",
                ".",
            ]
        )
        if outcome.returncode:
            exit(outcome.returncode)

    return None


###################################


def usage():
    print("Usage: build.py [options]")
    print("Options:")
    print("  -h, --help            Show this help message and exit")
    print("  -j N                  Number of processors to use [Default: 1]")
    print("  -c, --clean           Clean build [Default: False]")
    print("  --build-dir DIR       Build directory [Default: 'build']")
    print("  --no-tests            Do not build tests [Default: False]")
    print("  --cxx-std STD         C++ standard to use [Default: 'c++17']")
    print(
        "  --build-type TYPE     Build type (e.g., Release, Debug) [Default: 'Release']"
    )
    print(
        "  --output-to-file      Output logs to file instead of terminal [Default: False]"
    )


# NEW
class BuildParser(argparse.ArgumentParser):
    """Argument parser for build script"""

    def __init__(self) -> None:

        # Default initialization
        super().__init__(prog="build.py", description="Build tools for Tudat")

        # Control basic behavior of the build script
        basic_group = self.add_argument_group("Basic configuration")
        basic_group.add_argument(
            "--skip-tudat",
            dest="build_tudat",
            action="store_false",
            help="Do not build tudat",
        )
        basic_group.add_argument(
            "--skip-tudatpy",
            dest="build_tudatpy",
            action="store_false",
            help="Do not build tudatpy",
        )
        basic_group.add_argument(
            "--tests",
            dest="build_tests",
            action="store_true",
            help="Build with tests",
        )
        basic_group.add_argument(
            "--stubs",
            dest="generate_stubs",
            action="store_true",
            help="Generate stubs for tudatpy",
        )

        # Control CMake behavior
        cmake_group = self.add_argument_group("CMake configuration")
        cmake_group.add_argument(
            "-j",
            metavar="<cores>",
            type=int,
            default=1,
            help="Number of processors to use",
        )
        cmake_group.add_argument(
            "--cxx-standard",
            metavar="<std>",
            default="14",
            help="C++ standard to use",
        )
        cmake_group.add_argument(
            "--clean",
            dest="clean_build",
            action="store_true",
            help="Clean build directory before setup",
        )
        cmake_group.add_argument(
            "--build-dir",
            metavar="<dir>",
            default="build",
            help="Build directory",
        )
        cmake_group.add_argument(
            "--force-setup",
            dest="force_setup",
            action="store_true",
            help="Force the execution of CMake setup",
        )
        cmake_group.add_argument(
            "--build-type",
            metavar="<type>",
            default="Release",
            help="Build type (e.g., Release, Debug)",
        )

        # Control content of tudat

        # Misc
        misc_group = self.add_argument_group("Miscellaneous")
        misc_group.add_argument(
            "--verbose",
            action="store_true",
            help="Verbose output during build",
        )

        return None


class Builder:

    def __init__(self) -> None:

        # Command line arguments to control the build
        self.args = BuildParser().parse_args()

        # Build configuration attributes
        self.build_dir = Path(self.args.build_dir).resolve()
        self.skip_tudat = "OFF" if self.args.build_tudat else "ON"
        self.skip_tudatpy = "OFF" if self.args.build_tudatpy else "ON"
        self.build_tests = "ON" if self.args.build_tests else "OFF"

        return None

    def build_libraries(self) -> None:

        # If clean build is requested, delete build directory
        if self.build_dir.exists() and self.args.clean_build:

            # TODO: Logger
            print(f"Removing pre-existing build directory: {self.build_dir}")
            shutil.rmtree(self.build_dir)

        # If build directory still exists, skip setup
        if not self.build_dir.exists() or self.args.force_setup:

            # Set up build directory
            self.build_dir.mkdir(parents=True, exist_ok=True)
            with chdir(self.build_dir):
                outcome = subprocess.run(
                    [
                        "cmake",
                        f"-DSKIP_TUDAT={self.skip_tudat}",
                        f"-DSKIP_TUDATPY={self.skip_tudatpy}",
                        f"-DCMAKE_PREFIX_PATH={CONDA_PREFIX}",
                        f"-DCMAKE_INSTALL_PREFIX={CONDA_PREFIX}",
                        f"-DCMAKE_CXX_STANDARD={self.args.cxx_standard}",
                        "-DBoost_NO_BOOST_CMAKE=ON",
                        f"-DCMAKE_BUILD_TYPE={self.args.build_type}",
                        f"-DTUDAT_BUILD_TESTS={self.build_tests}",
                        "-B",
                        f"{self.build_dir}",
                        "-S",
                        "..",
                    ],
                    # stdout=output_dest,
                    # stderr=output_dest,
                )
            if outcome.returncode:
                shutil.rmtree(self.build_dir)
                raise RuntimeError("CMake setup failed")

        # Run build command
        with chdir(self.build_dir):

            build_command = ["cmake", "--build", ".", f"-j{self.args.j}"]
            if self.args.verbose:
                build_command.append("--verbose")
            outcome = subprocess.run(build_command)
            if outcome.returncode:
                exit(outcome.returncode)

    def generate_stubs(self) -> None:
        """Stub generator"""

        raise NotImplementedError("Stub generation not implemented yet")

        return None


if __name__ == "__main__":

    # Initialize argument parser and builder
    args = BuildParser().parse_args()
    builder = Builder()

    # Build libraries
    if not args.generate_stubs:
        builder.build_libraries()

    # Generate stubs
    builder.generate_stubs()

    exit(0)

    # ARGUMENTS = {
    #     "NUMBER_OF_PROCESSORS": 1,
    #     "CLEAN_BUILD": False,
    #     "BUILD_DIR": "build",
    #     "BUILD_TESTS": True,
    #     "RUN_TESTS": True,
    #     "CXX_STANDARD": "14",
    #     "BUILD_TYPE": "Release",
    #     "OUTPUT_TO_FILE": False,
    #     "OUTPUT_FILE": "build/build_output.txt",
    # }
    # CONDA_PREFIX = os.environ["CONDA_PREFIX"]

    # # Parse input
    # args = iter(sys.argv[1:])
    # for arg in args:
    #     if arg in ("-h", "--help"):
    #         usage()
    #         exit(0)
    #     elif arg == "-j":
    #         ARGUMENTS["NUMBER_OF_PROCESSORS"] = next(args)
    #     elif arg in ("-c", "--clean"):
    #         ARGUMENTS["CLEAN_BUILD"] = True
    #     elif arg == "--build-dir":
    #         ARGUMENTS["BUILD_DIR"] = next(args)
    #     elif arg == "--no-tests":
    #         ARGUMENTS["BUILD_TESTS"] = False
    #     elif arg == "--cxx-std":
    #         ARGUMENTS["CXX_STANDARD"] = next(args)
    #     elif arg == "--build-type":
    #         ARGUMENTS["BUILD_TYPE"] = next(args)
    #     elif arg == "--output-to-file":
    #         ARGUMENTS["OUTPUT_TO_FILE"] = True
    #     else:
    #         print("Invalid command")
    #         usage()
    #         exit(1)

    # # Determine output destination
    # if ARGUMENTS["OUTPUT_TO_FILE"]:
    #     output_dest = open(ARGUMENTS["OUTPUT_FILE"], "w")
    # else:
    #     output_dest = None

    # try:
    #     # Ensure build directory exists
    #     build_dir = Path(ARGUMENTS["BUILD_DIR"]).resolve()
    #     build_dir.mkdir(parents=True, exist_ok=True)

    #     # Build
    #     with chdir(build_dir):
    #         outcome = subprocess.run(
    #             [
    #                 "cmake",
    #                 f"-DCMAKE_PREFIX_PATH={CONDA_PREFIX}",
    #                 f"-DCMAKE_INSTALL_PREFIX={CONDA_PREFIX}",
    #                 f'-DCMAKE_CXX_STANDARD={ARGUMENTS["CXX_STANDARD"]}',
    #                 "-DBoost_NO_BOOST_CMAKE=ON",
    #                 f'-DCMAKE_BUILD_TYPE={ARGUMENTS["BUILD_TYPE"]}',
    #                 f'-DTUDAT_BUILD_TESTS={ARGUMENTS["BUILD_TESTS"]}',
    #                 "..",
    #             ],
    #             stdout=output_dest,
    #             stderr=output_dest,
    #         )
    #         if outcome.returncode:
    #             exit(outcome.returncode)

    #         build_command = ["cmake", "--build", "."]
    #         if ARGUMENTS["CLEAN_BUILD"]:
    #             build_command.append("--target")
    #             build_command.append("clean")
    #         build_command.append(f"-j{ARGUMENTS['NUMBER_OF_PROCESSORS']}")
    #         outcome = subprocess.run(
    #             build_command, stdout=output_dest, stderr=output_dest
    #         )
    #         if outcome.returncode:
    #             exit(outcome.returncode)
    # finally:
    #     if output_dest:
    #         output_dest.close()
